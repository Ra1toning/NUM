# 3 Стак, Дараалал, Жагсаалт
![GitHub Classroom Workflow](../../workflows/GitHub%20Classroom%20Workflow/badge.svg?branch=main) ![Points badge](../../blob/badges/.github/badges/points.svg)

Энэ хүү даалгавраар стак (stack), дараалал (queue), жагсаалт (list) бүтцүүдийг динамикаар буюу хаяган хувьсагч ашиглан хэрэгжүүлнэ. Ингэснээр бид хүснэгтийн хэмжээнд баригдахгүй санах ойн хэмжээгээр өгөгдөл хадгалж болох юм.

**Даалгаврын хийхдээ `NULL` хаягт хандвал үргэлж `segmentation fault` авахыг анхаарна уу!**

## Ерөнхий файл
`DS.h` нь бүтцийн ерөнхий толгой файл. Дотор нь Stack, Queue, List бүтцүүд тодорхойлогдсон ба тэдгээр дээр хийгдэх үйлдлүүдийн функцийн зарлалт байна. Уг файлыг өөрчлөх ёсгүй.

## Makefile
`Makefile` нь `make` хэрэгсэл ашиглан компайл хийх команд бичигдсэн байна. Уг файлыг томоохон төсөлд ашигладаг бөгөөд компайл хийх үйлдлүүдийг салгаснаар зөвхөн өөрчлөлт орсон файлыг салгаж компайл хийх боломж бүрддэг.

Компайл хийх процесс нь дараах шатуудаас бүрддэг.
  1. Урьдчилан боловсруулах (Preprocess): Макро болон preprocess командуудыг задлан нэг файлд хийнэ. Жишээ нь `#include`-ээр агуулсан бүх файлын доторхыг тухайн файлд нэмж залган кодын файлыг баяжуулна.  
  2. Компайл хийх (Compile): Баяжуулсан файлыг компайл хийж ассемблер код болно.  
  3. Ассембле хийх (Assemble): Ассеблер кодыг тухайн системийн архитектурт нийцсэн хоёртын файл болгон гаргана. Уг файлыг объект код гэж нэрлэдэг.  
  4. Холбох (Link): Объект кодуудыг нэгтгэн ажиллуулж болох файл буюу exe файлыг гарга. Уг файл, бидний ажиллуулдаг програм болно.  

Дараах мөр `stack.o` гэдэг объект файл нь `stack.c, DS.h` файлуудаас хамаарахыг илтгэнэ. Ингэснээр `stack.c, DS.h` файлуудад өөрчлөлт орсон бол заагдсан командын дагуу `stack.o`-г шинээр үүсгэнэ.
```
stack.o: stack.c DS.h
	gcc -c stack.c -o stack.o
```

`make` ашиглаж компайл хийхдээ тухайн хавтас дотроос дараах командаар компайл хийнэ (make суусан бөгөөд програм хайх зам дээр байх ёстой). 
```
make
```
Үр дүнд нь `all: lqs` мөр ажиллаж `lqs` програм файлыг үүсгэнэ. Үүнийг
```shell
./lqs
```
командаар ажиллуулна.  

Програмыг компайл хийхэд заавал `make` ашиглах шаардлагагүй. Дараах командаар компайл хийх боломжтой.
```shell
gcc *.c -o lqs
./lqs
```


## Даалгаврыг хийх заавар

Энэ даалгаврыг хийхэд шаардлагатай мэдлэг:
  1. Си хэлний бүтэц (struct)
  2. Си хэлний хаяган хувьсагч, дам хандалтын ойлголт (pointer, dereference)
  3. Динамикаар санах ой хуваарилах
  
Бүтцүүдэд орох бүхэл тоог дараах `Elm` бүтцэд хадгална.

| Elm   |
|:-----:|
| x     |
| *next |

`x` талбарт бүхэл тоог хадгална. `next` талбарт дараагийн элементийн хаягийг хадгална.
```C
struct Elm {
        int x;
        struct Elm *next;
};
typedef struct Elm Elm;
```

Хүснэгт бол санах ойд дарааллан байдаг. Харин динамикаар үүсгэсэн ой санах ойд энд тэнд байрлах тул, тэдгээрийг дараалалд оруулахын тулд (дарааллын дараагийн элемент гэсэн ойлголт) `next` хаяган хувьсагч ашиглагдана.

### Стак (Stack)

Стак нь хамгийн сүүлд оруулаад, сүүлээс гаргадаг өгөгдлийн бүтэц. `DS.h` файлд зарлагдсан `Stack` бүтцийг ашиглана.
```C
struct Stack {
        Elm *top;
        int len;
};
```
`top` хаяган хувьсагч үргэлж хамгийн сүүлд орсон элемент бүтцийн хаяг, `len` нь хэдэн элемент стакт хадгалагдаж байгааг заана. Харин стакт орох `Elm` бүтцүүдийн хувьд `x` нь оруулсан тоог хадгалах бол `next` нь өмнөх элементийнхээ хаягийг хадгалах ёстой.

Дараах үйлдлүүдийг хийх функцүүдийг хэрэгжүүлнэ. Эдгээр функцүүд нь `Stack` бүтцийн гишүүдэд хандах буюу `p->top` гэж хандан стакын хамгийн дээр байгаа элементийн хаягийг авч ашиглана.
  * Төгсгөлд нь оруулах үйлдэл. `p`-ийн зааж буй стакт `x` утгыг оруулна. `p->top`-ын зааж буй хаяг өөрчлөгдөнө. `p->len` нэмэгдэнэ.
    ```C
    void s_push(Stack *p, int x);
    ```
  * Төгсгөлөөс нь гаргах үйлдэл. `p`-ийн зааж буй стакаас гарах функц. `p->top`-ын зааж буй хаяг өөрчлөгдөнө. `p->len` хорогдоно.
    ```C
    void s_pop(Stack *p);
    ```
  * `p`-ийн зааж буй стакт байгаа элементүүдийг хэвлэх функц. Хамгийн сүүлд орсон элементээс эхлэн дарааллаар, нэг мөрөнд нэг л элемент хэвлэнэ.
    ```C
    void s_print(Stack *p);
    ```
    Жишээ нь стакт `1 8 7 3` гэсэн элементүүд байгаа ба `3` нь хамгийн сүүлд орсон бол
    ```
    3
    7
    8
    1
    ```
    гэж хэвлэнэ.
    
### Дараалал (Queue)

Дараалал гэдэг нь хамгийн төгсгөлд нь оруулаад, гаргахдаа хамгийн эхнээс нь гаргах функц. `DS.h` файлд зарлагдсан `Queue` бүтцийг ашиглана.
```C
struct Queue {
        Elm *head;
        Elm *tail;
        int len;
};
```
  * `head`: Хамгийн эхний эхэнд байх элемент бүтцийн хаягийг хадгална.
  * `tail`: Хамгийн сүүлд байх элемент бүтцийн хаягийг хадгална.
  * `len`: Дараалалд байгаа элементүүдийн тоог хадгална.

Дараах функцүүд нь `Queue` бүтцийн гишүүдэд хандах буюу `p->head, p->tail, p->len` гэх маягаар хандана.

  * Төгсгөлд нь оруулах үйлдэл. `p`-ийн зааж буй дараалалд `x` утгыг хийнэ. `p->tail`-ын зааж буй хаяг өөрчлөгдөнө. `p->len` нэмэгдэнэ.
    ```C
    void q_push(Queue *p, int x);
    ```
  * Эхлэлээс нь гаргах үйлдэл. `p`-ийн зааж буй дарааллаас хамгийн эхэнд орших элементийг гаргана. Динамик бүтэц тул бүх элементийг хөдөлгөх биш харин зохих санах ойн холболтуудыг хийнэ. `p->head`-ын зааж буй хаяг өөрчлөгдөнө. `p->len` хорогдоно.
    ```C
    void q_pop(Queue *p);
    ```
  * `p`-ийн зааж буй дараалалд байгаа элементүүдийг хэвлэх функц. Хамгийн эхэнд байгаа элементээс эхлэн дарааллаар, нэг мөрөнд нэг л элемент хэвлэнэ. 
    ```C
    void q_print(Queue *p)
    ```
    Жишээ нь дараалалд `1 8 7 3` гэсэн элементүүд байгаа ба `1` нь хамгийн эхэний элемент бол
    ```
    1
    8
    7
    3
    ```
    гэж хэвлэнэ.


### Жагсаалт (List)

Жагсаалт бүтэц нь дурын байрлалд оруулаад, дурын байрлалаас гаргах боломжтой бүтэц. `DS.h` файлд зарлагдсан `List` бүтцийг ашиглана.
```C
struct List {
        Elm *head;
        Elm *tail;
        int len;
};
```
  * `head`: Хамгийн эхний эхэнд байх элемент бүтцийн хаягийг хадгална.
  * `tail`: Хамгийн сүүлд байх элемент бүтцийн хаягийг хадгална.
  * `len`: Дараалалд байгаа элементүүдийн тоог хадгална.

Дараах функцүүд нь `List` бүтцийн гишүүдэд хандах буюу `p->head, p->tail, p->len` гэх маягаар хандана.

  * Төгсгөлд нь оруулах үйлдэл. `p`-ийн зааж буй жагсаалтад `x` утгыг төгсгөлд хийнэ. `p->tail`-ын зааж буй хаяг өөрчлөгдөнө. `p->len` нэмэгдэнэ.
    ```C
    void l_push_back(List *p, int x)
    ```
  * Эхлэлд нь оруулах үйлдэл. `p`-ийн зааж буй жагсаалтад `x` утгыг эхэнд хийнэ. Харгалзах хаягийн холбоосуудыг хийж хамгийн эхэнд оруулна. Тиймээс `p->head` зааж буй хаяг өөрчлөгдөх ёстой. `p->len` нэмэгдэнэ.
    ```C
    void l_push_front(List *p, int x)
    ```
  * Дурын байрлалд оруулах үйлдэл. `p`-ийн зааж буй жагсаалтад `x` утгыг `pos` байрлалд хийнэ. Тухайн байрлалд оруулах боломжгүй тохиолдолд хамгийн төгсгөлд оруулна. Хаана орж байгаагаас шалтгаалан `p->head, p->tail` өөрчлөгдөх боломжтой. `p->len` нэмэгдэнэ. Байрлалыг 0-ээс эхлүүлэн тооцно.
    ```C
    void l_insert(List *p, int x, int pos)
    ```
  * Төгсгөлөөс нь гаргах үйлдэл. `p`-ийн зааж буй жагсаалтын төгсгөлөөс гаргана. `p->tail` өөрчлөгдөнө. `p->len` хорогдоно. 
    ```C
    void l_pop_back(List *p)
    ```
  * Эхлэлээс нь гаргах үйлдэл. `p`-ийн зааж буй жагсаалтын эхлэлээс гаргана. `p->head` өөрчлөгдөнө. `p->len` хорогдоно.
    ```C
    void l_pop_front(List *p)
    ```
  * Дурын байрлалаас гаргах үйлдэл. `p`-ийн зааж буй жагсаалтын `pos` байрлалаас гаргана. `pos` байрлалаас гаргах боломжгүй бол юу ч хийхгүй. Хаанаас гаргаж байгаас шалтгаалан `p->head, p->tail` өөрчлөгдөх боломжтой. `p->len` хорогдоно. Байрлалыг 0-ээс эхлүүлэн тооцно.
    ```C
    void l_erase(List *p, int pos)
    ```
  * Жагсаалтаас хайх үйлдэл. `p`-ийн зааж буй жагсаалтаас `x` тоог хайн хамгийн эхэнд олдсоны `Elm*` хаягийг буцаана. Олдохгүй бол `NULL` хаяг буцаана.
    ```C
    Elm *l_search(List *p, int x)
    ```
